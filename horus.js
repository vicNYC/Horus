const fs = require('fs');
const grpc = require('grpc');
const path = require('path');

class horus {
  constructor(name) {
    this.serviceName = name; // represents the name of the microservices
    this.startTime = null;
    this.endTime = null;
    this.request = {};
    // this.requestId = 1; // NEED TO FIX !!!
    this.targetService = null; // represents the location to which the request was made
    this.allRequests = []; // array which stores all requests
    this.call;
  }
 
  // start should be invoked before the request is made
      // start begins the timer and initializes the request as pending
  start(targetService, call) {
    this.startTime = Number(process.hrtime.bigint());
    this.request[targetService] = 'pending'; // {books: 'pending', responseTime: 'pending'} 
    this.request.responseTime = 'pending';
    this.targetService = targetService;
    this.call = call;
  }
  // end should be invoked when the request has returned
  end() {
    this.endTime = Number(process.hrtime.bigint());
    this.request.responseTime = ((this.endTime - this.startTime)/ 1000000).toFixed(3); //converting into ms.
    this.sendResponse();
  }
  // grabTrace accepts inserts trace into request
      // trace represents the "journey" of the request
      // trace expects metaData to be 'none when the server made no additional requests
      // trace expects metaData to be the request object generated by the server otherwise
      // in gRPC, the trace must be sent back as meta data. objects should be converted with JSON.parse
  grabTrace (metaData) { 
    console.log('incoming meta data ', metaData)
    if (metaData === 'none') this.request[this.targetService] = 'none';
    else {
      metaData = JSON.parse(metaData);
      this.request[this.targetService] = metaData;
    }
    this.allRequests.push(this.request);
    this.sendResponse();
  }
  // displayRequests logs to the console all stored requests
    // setTimeout builds in deliberate latency since metadata may be sent before or after a request is done processing
  displayRequests () {
    console.log('\n\n');
    console.log('Logging all requests from : ', this.serviceName);
    this.allRequests.forEach((request) => {
      console.log('\n');
      console.log(request);
    });
    console.log('\n\n');
  }
  // sends response via metadata if service is in the middle of a chain
  sendResponse() {
    if (this.request.responseTime === 'pending' || 
      this.request[this.targetService] === 'pending' ||
      this.call === undefined) return;
    let meta = new grpc.Metadata();
    meta.add('response', JSON.stringify(this.request));
    this.call.sendMetadata(meta);
  }
  writeToFile() {
    let strRequests = '';
    for (let req of this.allRequests) {
      strRequests += `${Object.keys(req)[0]} (service) response received at: ${Object.values(req)[1]} ms (Total)`;
      strRequests += '\n';

      // while we dont hit an empty object on the 1st key, go inside
      let innerObj = Object.values(req)[0];
      while (innerObj !== 'none') {
        strRequests += `${Object.keys(innerObj)[0]} (service) response received at: ${Object.values(innerObj)[1]} ms`;
        strRequests += '\n';
        innerObj = Object.values(innerObj)[0];
      }
      strRequests += '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n';
    }

    fs.writeFile('requestData4.txt', strRequests, {flag:'a+'}, (err) => {
      if(err) {
        console.error(err);
      }
    });   //'a+' is append mode
  }
}

module.exports = horus;